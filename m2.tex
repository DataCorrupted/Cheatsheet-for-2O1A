\section*{Midterm 2 (Feb 28, 2020)}

\problem{
    f15m2q1
}{
    Give 1 technique that can be used to reduce the Miss Rate.
}{
    \todo
}

\problem{
    f15m2q2
}{
    Give 1 technique that can be used to reduce the Hit Time.
}{
    \todo
}

\problem{
    f14m2q4
    f15m2q5
}{
    What does ROB stand for, and why is it used in modern advanced pipelines? 
}{
    Reorder Buffer. 

    It can dynamically execute code while maintaining a precise interrupt.
}

\problem{
    f16m2q1
}{
    Writes to a cache are inherently slower than reads from a cache - why?
}{
     \todo
}

\problem{
    f14m2q1
    f15m2q3
    f16m2q2
    w12m2q10
}{
    What is the primary difference between Tomasulo’s algorithm and Scoreboarding?
}{
    Tomasulo’s: distributed; scoreboarding: centralized.

    \warn{Common data bus(CDB)}
}

\problem{
    f15m2q6
    f16m2q3
}{
    Compilers have trouble optimizing code that involves reads and writes to memory. Why? (The answer has nothing to do with how slow memory is - that is a different problem altogether).
}{
     \todo
}

\problem{
    f15m2q4
    f16m2q4
}{
    What is the definition of a basic block? 
    Why is there a desire to create larger basic blocks? 
    Give one example of a way to create a bigger basic block.
}{
    A straight-line code sequence with no branches in except to the entry and no branches out except at the exit.\pg{149}

    So compilers can optimize more.

    Loop unrolling
}

\problem{
    f15m2q7
    f16m2q6
}{
    Intel uses a Tournament predictor in some of their processors. 
    Describe what it is, and why it is used. 
    Your description can (and probably should) include sketches and drawings.
}{
     \todo
}

\problem{
    f16m2q7
}{
    Why is loop unrolling a valuable optimization technique? What are 2 challenges to using it?
}{
     \todo
}

\problem{
    f12m2q10
    f14m2p2
    f15m2q8
    f16m2q8
}{
    The book states that slow and wide architectures can be more power-efficient than fast and narrow architectures. 
    Explain why. 
    Also, explain the underlying assumption that is being made, and why it is that we are still making narrow fast machines.
}{
    Slow and wide can lower both clock rate and voltage.
    Lowering $V$ and $f$ means the power goes down since $P = C \cdot f \cdot V^2$.

    If there is enough data-level parallelism, then slow and wide can provide the same throughput as fast and narrow while using less power. 
    There is not always enough DLP though.
}

\problem{
    f16m2q9
}{
    Supporting precise interrupts in machines that allow out of order completion is a challenge. Briefly explain what a precise interrupt is, why it is a challenge in OOO machines, and describe the main technique used today to provide precise interrupts.
}{
     \todo
}

\problem{
    f15m2q11
    f16m2q10
}{
    Briefly outline how a Vector machine works, and what type of parallelism it is exploiting.
}{
    \todo

    Data level parallelism(SIMD)
}

\problem{
    f04m1q16
    w10m1q10
    w12f0p1
    f13f0p1
    f14m2p2
    f15m2q12
    f15f0p2
    f15f1p1
    f16m2q11
    f16f0p1
}{
    What is the primary difference between superscalar and VLIW processors? 
    Give one advantage and one disadvantage of using each approach. / Compare and contrast VLIW and superscalar with two advantages and one disadvantage.
    (These have to be different - in other words, if the advantage of superscalar is X, then you can’t say a disadvantage of VLIW is that it can’t do X.)
}{
    Superscalar uses hardware to do dynamic scheduling, while VLIW uses software to do static scheduling.

    Pro of superscalar: No recompilation on hardware changes. \\
    Con of superscalar: Hardware complexity.

    Pro of VLIW: Power efficient. \\
    Con of VLIW: Memory ambiguity.
}

\problem{
    f14m2p2
    f14f0p1
    f15m2q9
    f15f1p1
    f16m2q12
    f16f0p1
}{
    You have been writing C programs for a simple, non-pipelined machine. 
    You have recently received a promotion, and now your job is to write C programs for a heavily pipelined, high-performance processor. 
    These new programs must execute as fast as possible (the emphasis is on response time, not throughput). 
    Give at least 2 examples of things you should do differently now, and be sure to explain in detail why 
    (what is the problem you are overcoming?)
}{
    \begin{enumerate}
        \item Use fewer pointers, as they make compilers hard to do optimization.
        \item Write incline code so I can make bigger basic blocks.
    \end{enumerate}
}

\problem{
    f14m2q2
}{
    Which data hazard occurs when instructions are allowed to complete out of order? 
    Which one occurs when instructions are allowed to issue out of order?
}{
    \todo
}

\problem{
    f14m2q5
}{
    Speculation is a very useful technique for improving performance. 
    However, it is not being used as extensively as it once was - why not?
}{
    \todo
}

\problem{
    f14m2q5
}{
    Compilers have trouble optimizing code that involves reads and writes to memory. Why? (The answer
has nothing to do with how slow memory is - that is a different problem altogether).
}{
    Hazards through the memory system.
}

\problem{
    f14m2q7
}{
    The book states that slow and wide architectures can be more power efficient than fast and narrow architectures. Explain why. Also, explain the underlying assumption that is being made, and why it is that we are still making narrow fast machines.
}{
    \todo
}

