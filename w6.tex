\newSection{Week 6 (Chp.3, Quiz 4)}

\problem{
    f13m2q3
    w20q4q1
}{
    Accurate dynamic branch prediction is more difficult for which type of benchmark, Int or Float
}{
    Int. 
}

\problem{
}{
    Why is branch prediction important? 
    List 3 dynamic branch prediction strategies in order of (average) increasing effectiveness.
}{
    Because it decreases the cycles stalled while waiting for the branch result.

    \begin{itemize}
        \item 2 bit counter
        \item Correlating branch predictor
        \item Tournament predictor
    \end{itemize}
}

\problem{
    f06m1q15
    w10m1q13
    f12m2q12
    w12m2q13
    f13m2q9
    f13f0p4
    f15m2q4
    f15f0p4
    f16m2q4
    w19m2q5
    w19f0q28
    w20q4q2
    w20m2q6
}{
    What is the definition of a basic block? 
    Why is there a desire to create larger ones? 
    Give one example of a way to create a bigger basic block.
}{
    A straight-line code sequence with no branches in except to the entry and no branches out except at the exit.\pg{149}

    So compilers can do more code scheduling and optimization.

    Loop unrolling
}

\problem{
    w20q4q3
}{
    What's an example of a commonly occurring indirect branch, and a hardware structure used to deal with it?
}{
    Subroutines / Functions

    Return address stack
}

\problem{
    f13m2q14
    f14m2p1
    f15m2q6
    f15f0p5
    f16m2q3
    w19m2q4
    w20q4q5
    w20m2q3
}{  
    Compilers have trouble optimizing code that involves reads and writes to memory, why?
}{
    Hazard through the memory system.

    \OR

    Hazards through memory system makes it hard to optimize the code by compiler. 
    Finding dependencies through memory is hard. 
    Compilers can't calculate the physical address at compile time, only hardware knows in runtime. 
}

\problem{
    f16m2q7
    w20q4q6
}{
    Why is loop unrolling a valuable optimization technique? 
    What are 2 challenges to using it?
}{
    It allows us to make bigger basic blocks to do code scheduling 

    \begin{enumerate}
        \item The limited number of registers 
        \item Don't know how to decide how many times to unroll        
    \end{enumerate}

    \OR

    \begin{enumerate}
        \item Don't know how much to unroll  
        \item Register pressure        
    \end{enumerate}
}


\problem{
    f15m2q7
    f15f0p5
    f16m2q6
    f16f0p1
    w20q4q7
}{
    Intel uses a Tournament predictor in some of their processors. 
    Describe what it is, and why it is used. 
    Your description can (and probably should) include sketches and drawings.
}{
    Tournament predictor is a meta predictor that predicts which predictor should be used

    It's used because each predictor performs differently based on the situation. 
    For example, 2-bit predictor performs better than G-share when we jump to somewhere new. 
    But after G-share learns, it will perform better.
}

\problem{
    f12m2q13
    f13f0p4
    f16m2q9
    f16f0p1
    f15f0p4
    w19m2q11
    w19f0q29
    w19f0q30
    w20q4q8
    w20m2q13
}{
    What is the definition of a precise interrupt?
    Why precise interrupt is important?
    Why it is a challenge in \OOO(OOO) machines?
    The two main techniques used `to'day to provide a precise interrupt?
}{
    When an interrupt happens, every instruction before it has finished and none after can complete.
    
    To deal with a page fault. 
    \OR 
    Virtual Memory support requires that if you have a page fault, I have to go to service the page fault and come back to restart that instruction.


    \warn{Because instructions take a different amount of clock cycles to finish}

    ROB and \todo
}

\problem{
    f14m2q2
    f14f0p9
    f15f0p6
    f16f0p7
    w19m1q19
    w19f0q42
    w20q4q9
    w20q4q10
    w20m2q9
}{
    \info{Pipeline \& hazard, sampled from w19m1q42}

    The MIPS implementation we used in class has a 5-stage pipeline, writes to the register file during the first half of the cycle and reads during the second half, and uses both a branch delay slot and a load delay slot. 
    If the machine is redesigned to be an 8-stage pipeline, with the following stages:

    $$ F1 \quad F2 \quad D \quad E1 \quad E2 \quad M1 \quad M2 \quad WB$$ 

    \begin{enumerate}
        \item Assuming this machine has a branch predictor and the branch condition is calculated by the end of the $D$ stage, how big is the branch penalty (measured in cycles) when the prediction is incorrect? 
        What if the branch condition is not calculated until the end of $E2$?
    
        \item How many load delay slots would this machine need (assuming it has forwarding logic and you are forwarding to E2) assuming the memory returns the value by the end of M2? M1?
    
        \item What type of data hazard does the above pipeline need to worry about?
        
        \item If a standard pipeline is modified to support \OOO completion, what new data hazard is introduced?
        
        \item If in addition to completing \OOO, instructions were allowed to issue \OOO, what new data hazard would be introduced.        
    \end{enumerate}

}{
    \begin{enumerate}
        \item \todo
        \item \todo
        \item RAW
        \item WAW
        \item WAR
    \end{enumerate}
}

\problem{
    f13f0p4
    f14m2q4
    f15m2q5
}{
    What does ROB stand for, and why is it used in modern advanced pipelines? 
}{
    Reorder Buffer. 

    It can dynamically execute code while maintaining a precise interrupt.
}